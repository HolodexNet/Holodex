<template>
  <div class="channel-grid grid justify-items-stretch gap-4">
    <template v-for="(arr, group) in list" :key="group + '.group'">
      <div
        v-if="
          (groupKey === 'org' || groupKey === 'group') &&
          Object.keys(list).length > 1
        "
        class="col-span-full rounded-md bg-bgColor p-2 font-semibold shadow-md"
      >
        {{ arr[0] || "Unnamed Group" }}
      </div>
      <template v-for="(channel, idx) in arr[1] as any" :key="channel.id">
        <channel-card
          v-if="idx < 20 && (group as number) < 2"
          :channel="channel"
          :variant="variant"
          :slim="slim"
          class="bg-bgColor shadow-xl"
        >
          <template
            v-if="$slots.default"
            #buttons="{ channelData, channelActions }"
          >
            <slot
              :channel-data="channelData"
              :channel-actions="channelActions"
            />
          </template>
        </channel-card>
        <h-lazy v-else style="min-height: 116px">
          <channel-card
            :channel="channel"
            :variant="variant"
            :slim="slim"
            class="bg-bgColor shadow-xl"
          >
            <template
              v-if="$slots.default"
              #buttons="{ channelData, channelActions }"
            >
              <slot
                :channel-data="channelData"
                :channel-actions="channelActions"
              />
            </template>
          </channel-card>
        </h-lazy>
      </template>
    </template>
  </div>
  <query-status v-if="!!query" :query="resp as any" />
</template>
<script lang="ts">
import { useChannels } from "@/services/channel";
import { PropType } from "vue";
// import { useInfiniteScroll } from "@vueuse/core";

interface QueryType {
  type: string;
  org?: string;
  sort?: string;
  order?: string;
}

export default defineComponent({
  props: {
    channels: {
      type: Array as PropType<FullChannel[]> | undefined,
      default: undefined,
    },
    query: {
      type: Object as PropType<QueryType> | undefined,
      default: undefined,
    },
    variant: {
      type: String as PropType<"card" | "list">,
      default: "list",
    },
    grouping: {
      type: String as PropType<"org" | "group" | string>,
      default: "none",
    },
    slim: Boolean,
  },
  setup(props) {
    const respChannels = useChannels(
      computed(() => props.query || {}),
      computed(() => props.channels === undefined),
    );

    const groupKey = computed(() => {
      return props.grouping === "org" || props.grouping === "group"
        ? props.grouping
        : "none";
    });

    const list = computed(() => {
      if (props.channels)
        return Object.entries(
          props.channels.reduce(
            // groupBy on `groupKey.value`
            (
              r,
              v,
              i,
              a,
              k = groupKey.value === "none" ? "*" : v[groupKey.value] || "",
            ) => ((r[k] || (r[k] = [])).push(v), r),
            {} as Record<string, FullChannel[]>,
          ),
        );
      if (respChannels.data.value)
        return Object.entries(
          ([] as FullChannel[])
            .concat(...respChannels.data.value.pages) // flatten
            .reduce(
              // groupBy on `groupKey.value`
              (
                r,
                v,
                i,
                a,
                k = groupKey.value === "none" ? "*" : v[groupKey.value] || "",
              ) => ((r[k] || (r[k] = [])).push(v), r),
              {} as Record<string, FullChannel[]>,
            ),
        );
      return [["", []]];
    });
    return { list, groupKey, resp: respChannels };
  },
  methods: {
    async intersect() {
      console.log("intersecting", this.resp.hasNextPage?.value);
      if (this.resp?.hasNextPage?.value) {
        await this.resp.fetchNextPage();
      }
    },
  },
});
</script>
<style>
/* 1fr = "fraction unit", which is ratio basis of remaining space.
  https://developer.mozilla.org/en-US/docs/Web/CSS/repeat#auto-fill <- for autofill. 
  autofill: (= largest possible positive integer that does not cause the grid to overflow its grid)

  minmax is basically saying between the left and right, the left being minimum size, which is 30rem,
   or when the screen is really small, 90%vw.
*/

.channel-grid {
  grid-template-columns: repeat(auto-fill, minmax(min(30rem, 90vw), 1fr));
}
</style>
