<template>
  <h-tabs xclass="mb-4 bg-bgColor-500">
    <h-tab
      :active="currentTab === 0"
      class="shrink"
      style="text-overflow: &quot;&quot;; white-space: nowrap; overflow: hidden"
      @click="() => updateTab(0)"
    >
      {{ liveUpcomingHeaderSplit[1] }}
      <span
        v-if="liveUpcomingCounts.liveCnt"
        class="badge-secondary badge badge-sm mx-1 rounded-sm sm:badge-md"
      >
        {{ liveUpcomingCounts.liveCnt }}
      </span>
      {{ liveUpcomingHeaderSplit[2] }}
      <span
        v-if="liveUpcomingCounts.upcomingCnt"
        class="badge-outline badge badge-sm mx-1 rounded-sm sm:badge-md"
      >
        {{ liveUpcomingCounts.upcomingCnt }}
      </span>
    </h-tab>
    <h-tab :active="currentTab === 1" @click="() => updateTab(1)">
      {{ $t("views.home.recentVideoToggles.official") }}
    </h-tab>
    <h-tab :active="currentTab === 2" @click="() => updateTab(2)">
      {{ $t("views.home.recentVideoToggles.subber") }}
    </h-tab>
    <template #filters>
      <home-filter-button />
    </template>
  </h-tabs>
  <div class="relative px-4">
    <!-- TODO: make this better -->
    <div v-if="props.favorites && !isLoggedIn">Please login</div>
    <!-- Set opacity to 0 to prevent wrong data being shown immediately, but prerender -->
    <video-card-grid
      :class="{
        'absolute opacity-50':
          videoQuery.isLoading.value || videoQuery.isFetching.value,
      }"
      class="z-[2] transition-opacity"
    >
      <template v-for="(video, index) in videosToShow" :key="video.id">
        <video-card
          v-if="index < 20"
          :video="video"
          :hide-channel-image="currentTab == Tabs.CLIPS"
        />
        <h-lazy v-else class="lazy-video-card">
          <video-card
            :video="video"
            :hide-channel-image="currentTab !== Tabs.CLIPS"
          />
        </h-lazy>
      </template>
    </video-card-grid>

    <query-status
      :query="videoQuery"
      class="z-0 transition-transform"
      :class="[
        videoQuery.isLoading.value || videoQuery.isFetching.value
          ? 'absolute left-0 right-0 top-12 translate-y-4'
          : '',
      ]"
    />

    <div
      v-if="videoQuery.isSuccess.value && currentTab !== Tabs.LIVE"
      class="flex h-20 items-center justify-center"
    >
      <h-pagination v-model="currentPage" :total-pages="totalPages" />
    </div>
  </div>
</template>
<script setup lang="ts">
import { useVideoListDatasource } from "@/services/video";
import { Ref } from "vue";
import { useI18n } from "vue-i18n";
import HPagination from "@/components/core/HPagination.vue";
import { useUrlSearchParams } from "@vueuse/core";
import useOrgRouteParamSync from "@/hooks/common/useOrgRouteParamSync";
import { useClient } from "@/hooks/auth/client";
import { useVideoFilter } from "@/services/video-filter";
const { isLoggedIn } = useClient();

const props = defineProps({ favorites: Boolean });
const params = useUrlSearchParams("history");

const Tabs = {
  LIVE: 0,
  ARCHIVE: 1,
  CLIPS: 2,
} as const;
const currentTab: Ref<(typeof Tabs)[keyof typeof Tabs]> = ref(Tabs.LIVE);
const router = useRouter();
const route = useRoute();

const pageOrg = useOrgRouteParamSync();
// TODO:
// paginated: !this.scrollMode,
// ...(this.toDate && {
//   to: nearestUTCDate(dayjs(this.toDate ?? undefined)),
// }),
const lookupState: Ref<VideoListLookup> = ref({
  flavor: props.favorites
    ? ({
        favorites: props.favorites,
      } as FavLookup)
    : ({ org: pageOrg.value.name } as OrgLookup),
  // type & status for tab selection.
  // Usually selection has a tab between live and archives. Use this to control that aspect.
  type: "stream_schedule" as const,
  // optional if using a enum Type ^,
  // if custom type, then must provide custom statuses.
  statuses: undefined,

  // and regular pagination
  pagination: undefined,
});

watch(
  () => [props.favorites, pageOrg.value],
  () => {
    lookupState.value.flavor = props.favorites
      ? ({
          favorites: props.favorites,
        } as FavLookup)
      : ({ org: pageOrg.value.name } as OrgLookup);
  },
);

// const settings = useSettingsStore();
const currentPage = ref(+params.page || 1);
const perPage = 24;

const { t } = useI18n();

function updateTab(tab: number, preservePage = true) {
  // Change page before change tab, to avoid fetching wrong offset
  currentPage.value = 1;

  currentTab.value = tab as any;
  // Sync the hash to current tab
  const toHash: Record<number, string> = {
    0: "",
    1: "#archive",
    2: "#clips",
    3: "#list",
  };

  lookupState.value.pagination =
    tab === 0 ? undefined : { offset: 0, limit: perPage };

  switch (tab) {
    case 0:
      lookupState.value.type = "stream_schedule";
      break;

    case 1:
      lookupState.value.type = "archive";
      break;

    case 2:
      lookupState.value.type = "clip";
      break;
  }
  router
    .replace({
      hash: toHash[tab] || "",
      // set page to 0 if on scroll mode
      query: preservePage
        ? {
            ...route.query,
            page: undefined,
          }
        : {},
    })
    .catch((e) => {
      console.debug("Expected navigation duplication error", e);
      // Navigation duplication error expected, catch it and move on
    });
}

const videoQuery = useVideoListDatasource(lookupState, ref({ enabled: true }));

const videosToShow = useVideoFilter(videoQuery.data, lookupState);

const totalPages = computed(() => {
  return Math.ceil((videoQuery?.data.value?.total || 0) / perPage);
});

const liveUpcomingHeaderSplit = computed(() => {
  return [
    ...(t("views.home.liveOrUpcomingHeading").match(/(.+)([\\/／・].+)/) || []),
  ];
});

const liveUpcomingCounts = ref({ liveCnt: 0, upcomingCnt: 0 });
watchEffect(() => {
  if (lookupState.value.type === "stream_schedule") {
    const live = videosToShow.value;
    const liveCnt = live?.filter((v) => v.status === "live").length || 0;
    const upcomingCnt =
      live?.filter((v) => v.status === "upcoming").length || 0;
    liveUpcomingCounts.value = { liveCnt, upcomingCnt };
  } else {
    liveUpcomingCounts.value = { liveCnt: 0, upcomingCnt: 0 };
  }
});

// Scroll to top when page changes
watch(
  () => currentPage.value,
  () => {
    window.scrollTo({ top: 0 });
    params.page = `${currentPage.value}`;
    if (lookupState.value.pagination)
      lookupState.value.pagination.offset = (currentPage.value - 1) * perPage;
  },
);
// Reset to first tab when path changes
watch(
  () => route.path,
  () => updateTab(0, false),
);
// const isLoading = computed(
//   () => videoQuery?.isLoading.value || videoQuery?.isFetching.value
// );
// const error = computed(() => videoQuery?.error.value);
// const isError = computed(() => videoQuery?.isError.value);
</script>
<style>
/* shared with favorites.vue */
.stream-count-chip {
  letter-spacing: normal;
  min-width: 24px;
}

.lazy-video-card:empty {
  width: 1px;
  height: 0;
  padding-bottom: calc((100% / (16 / 9)) + 88px);
}

/* Hide scrollbar for Chrome, Safari and Opera */
.no-scrollbar::-webkit-scrollbar {
  display: none;
}

/* Hide scrollbar for IE, Edge and Firefox */
.no-scrollbar {
  -ms-overflow-style: none; /* IE and Edge */
  scrollbar-width: none; /* Firefox */
}
</style>
